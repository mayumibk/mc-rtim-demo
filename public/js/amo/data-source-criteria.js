"use strict";
/**
 * This class mimics the Java ReportCriteria class. Instances of
 * this class can be streamed in JSON format for use in ReportService requests.
 * This is integrated into Angular as a value. You inject this value into your
 * code and then create a new instance of the wrapped class: new value();
 *
 * See report-criteria-example.js for a view of a typical ReportCriteria
 * instance shown in JSON form.
 *
 * Created by kmonahan on 1/8/15.
 */

(function() {

    // Put some angular services into closure space so that we don't
    // have to pass them to the actual constructor function.
    var CONSTANTS, utils;

    var initializeBasicSettings =
            function() {
                var basicSettings = {
                    includeNoPerformanceRows: CONSTANTS.INCLUDE_NO_PERFORMANCE_ROWS,
                    includePerformanceData: CONSTANTS.INCLUDE_PERFORMANCE_DATA,
                    byClickDate: CONSTANTS.BY_CLICK_DATE
                };

                var BasicSettingsConstructor =
                    function(options) {
                        utils.copyReferences(options, basicSettings);
                    };

                BasicSettingsConstructor.prototype.setIncludeNoPerformanceRows = function(includeNoPerformanceRows) { basicSettings.includeNoPerformanceRows = includeNoPerformanceRows; };
                BasicSettingsConstructor.prototype.getIncludeNoPerformanceRows = function() { return basicSettings.includeNoPerformanceRows; };
                BasicSettingsConstructor.prototype.setIncludePerformanceData = function(includePerformanceData) { basicSettings.includePerformanceData = includePerformanceData; };
                BasicSettingsConstructor.prototype.getIncludePerformanceData = function() { return basicSettings.includePerformanceData; };
                BasicSettingsConstructor.prototype.setByClickDate = function(byClickDate) { basicSettings.byClickDate = byClickDate; };
                BasicSettingsConstructor.prototype.getByClickDate = function() { return basicSettings.byClickDate; };

                BasicSettingsConstructor.prototype.get = function() { return basicSettings; };

                return BasicSettingsConstructor;
            },
        initializeFilterInfo =
            /**
             * Defines constructors for the various types of filters that we use.
             */
            function() {
                // We have three types of simple filters. CompareFilter does a simple comparison between
                // an attribute and a value using the standard less than, less than or equal to,
                // etc. comparisons. StringFilter is similar to CompareFilter but uses the starts with,
                // ends with and equal to operators. Finally, IsOneOfFilter determines if the attribute
                // is in a list of values. From these three basic filters we define two additional aggregate
                // filter types. The CompoundFilter joins two or more filters--including aggregate
                // filters using AND, OR or NONE. The NotFilter simply negates the value of an existing
                // simple or aggregate filter.

                // CompareFilter
                var ComparableFilterConstructor =
                    /**
                     * A simple filter that compares attribute to value using the
                     * indicated operator. The operator is the typical <, <=, etc.
                     * By contrast, the similar string filter does starts with,
                     * ends with and equals.
                     * @param attribute The server name of the value we're comparing. Often
                     *              a database column or synthetic variable generated by a
                     *              SQL query.
                     * @param comparison From the data source constants: LESS_THAN, LESS_THAN_OR_EQUAL_TO,
                     *              EQUAL_TO, GREATER_THAN_OR_EQUAL_TO, GREATER_THAN
                     * @param value What we compare the attribute to
                     * @constructor
                     */
                    function( attribute, comparison, value ) {
                        this.attribute = attribute;
                        this.comparison = comparison;
                        this.value = value;
                    };
                ComparableFilterConstructor.prototype.getAttribute = function() { return this.attribute; };
                ComparableFilterConstructor.prototype.getComparison = function() { return this.comparison; };
                ComparableFilterConstructor.prototype.getValue = function() { return this.value; };

                // StringFilter
                var StringFilterConstructor =
                    /**
                     * A simple filter that does string-oriented comparison between an
                     * attribute and a value. The comparison is looking at substrings.
                     * @param attribute The server name of the value we're comparing. Often
                     *              a database column or synthetic variable generated by a
                     *              SQL query.
                     * @param comparison From the data source constants: STARTS_WITH, ENDS_WITH,
                     *              EQUALS, CONTAINS.
                     * @param value What we compare the attribute to
                     * @constructor
                     */
                    function( attribute, comparison, value, caseInsensitive ) {
                        this.attribute = attribute;
                        this.comparison = comparison;
                        this.value = value;
                        this.caseInsensitive = typeof caseInsensitive !== "undefined" ? caseInsensitive : true;
                    };
                StringFilterConstructor.prototype.getAttribute = function() { return this.attribute; };
                StringFilterConstructor.prototype.getComparison = function() { return this.comparison; };
                StringFilterConstructor.prototype.getValue = function() { return this.value; };
                StringFilterConstructor.prototype.isCaseInsensitive = function() { return this.caseInsensitive; };

                // CompoundFilter
                var CompoundFilterConstructor =
                    /**
                     * An aggregate of two or more filters where the results of
                     * each filter are then logically combined to produce the
                     * compound filter's result. The combination options are AND,
                     * OR and NOT. This allows complex filters like name starts_with "kevin"
                     * AND department = "AMO".
                     * @param filters A filter or an array of filters. A filter is any of the filter
                     *              types defined here, including other compound filters
                     * @param combination How the results of the individual filters are
                     *              viewed to determine the result of the compound filter.
                     *              The options are AND, OR and NOT. Note that the NOT
                     *              option is the same as the NotFilter and a compound
                     *              filter that uses OR.
                     * @constructor
                     */
                    function( filters, combination ) {
                        this.filters = !! filters ? (filters instanceof Array ? filters : [ filters ]) : [];
                        this.combination = !! combination ? combination : CONSTANTS.AND;
                    };

                CompoundFilterConstructor.prototype.getCombination =
                    function() { return this.combination; };
                CompoundFilterConstructor.prototype.getFilters =
                    function() { return this.filters; };

                CompoundFilterConstructor.prototype.addFilter =
                    /**
                     * Adds the supplied filter to the list of filters in this compound filter.
                     * @param filter
                     */
                    function( filter ) {
                        this.filters.push( filter );
                    };

                // NotFilter
                var NotFilterConstructor =
                    /**
                     * Just negates the result of the filter.
                     * @param filter A filter of any of the defined types--even this
                     *              filter although that would be to nots.
                     * @constructor
                     */
                    function( filter ) {
                        this.filter = filter;
                    };

                // The wrapper class for our query's filters. The instance of this
                // class--which is a singleton in the data source criteria object--
                // is referenced by the using data source.
                var FilterDefintionConstructor =
                    /**
                     * The data source criteria has a filter section that corresponds
                     * to an instance of this class.
                     * @options A predefined set of filter criteria.
                     * @constructor
                     */
                    function( options ) {
                        this.filter = !! options && !! options.filter ? options.filter : null;
                    };

                FilterDefintionConstructor.prototype.addFilter =
                    /**
                     * Adds a new filter to the set. If this is the first
                     * filter then we simply save it. If a filter has already
                     * been added then we either add it to an existing compound
                     * filter or we create a new compound filter from the new
                     * filter and the existing filter.
                     * @param filter
                     * @param aggregateOption
                     */
                    function( filter, aggregateOption ) {
                        if (! this.filter) {
                            this.filter = filter;
                        } else {
                            // There is an existing filter.
                            if (this.filter instanceof CompoundFilterConstructor) {
                                this.filter.addFilter( filter );
                            } else {
                                // The existing filter is not a compound filter. We now create
                                // a compound filter using the existing one and our new one.
                                this.filter = new CompoundFilterConstructor( [ this.filter, filter ], aggregateOption );
                            }
                        }
                    };

                FilterDefintionConstructor.prototype.setFilter =
                    /**
                     * This filter becomes the new filter definition for the object,
                     * replacing any existing filter that is there.
                     * @param filter The filter to use.
                     * @returns The previous filter, can be null.
                     */
                    function( filter ) {
                        var previousFilter = this.filter;
                        this.filter = filter;
                        return previousFilter;
                    };

                FilterDefintionConstructor.prototype.getFilter = function() { return this.filter; };

                // We attach the other constructors to the FilterDefinitionConstructor. This
                // lets outsiders
                return {
                    FilterDefinition: FilterDefintionConstructor,

                    ComparableFilter: ComparableFilterConstructor,
                    StringFilter: StringFilterConstructor,
                    CompoundFilter: CompoundFilterConstructor,
                    NotFilter: NotFilterConstructor
                };
            },

        initializeSortInfo =
            function() {
                var sortInfo = null;

                var SortInfoConstructor =
                    function( initialValues ) {
                        sortInfo = !! initialValues ? initialValues : [];
                    };

                SortInfoConstructor.prototype.addSort =
                    /**
                     * Adds the sort definition to the list, at the indicated position
                     * @param field The name of the field/column to sort on. In the grid
                     *              context, for example, this would be the name used in
                     *              the metadata to define the column
                     * @param direction Optional, "asc" or "desc". Default is "asc". See
                     *              the ASCENDING and DESCENDING constants in data source
                     *              constants.
                     * @param atEnd Optional, if true then append this new sort defintion to the
                     *              end of the sort list. If false then prepend it. Defaults
                     *              to true (put at end.)
                     */
                    function( field, direction, atEnd ) {
                        if ((typeof atEnd === "undefined") || atEnd) {
                            sortInfo.push( { direction: direction, field: field } );
                        } else {
                            sortInfo.unshift( { direction: direction, field: field } );
                        }
                    };

                SortInfoConstructor.prototype.setSort =
                    /**
                     * Clears the existing sort options and sets the supplied ones into place.
                     * @param sortOptions Either an array of sort definitions or a single hashmap
                     *                  with one sort definition. If null then the existing
                     *                  sort definitions are removed.
                     */
                    function( sortOptions ) {
                        // sortInfo can be null, a single instance of a sort info hash
                        // or an array. Use it to initialize sortInfo.
                        if (!! sortOptions) {
                            if (sortOptions instanceof Array) {
                                sortInfo = sortOptions;
                            } else {
                                sortInfo = [ sortOptions ];
                            }
                        } else {
                            sortInfo = null;
                        }
                    };

                SortInfoConstructor.prototype.getNumberOfSortDefinitions =
                    /**
                     * Just returns the number of sort specifications that are
                     * in our overall sort definition. Returns 0 if there are none
                     * or the definition has not been initialized.
                     */
                    function() {
                        return !! sortInfo ? sortInfo.length : 0;
                    };

                SortInfoConstructor.prototype.get =
                    function( index ) {
                        return (!! sortInfo && (index < sortInfo.length)) ? sortInfo[index] : null;
                    };

                return SortInfoConstructor;
            },

        initializeMap =
            function() {
                // The map attributes. I'm violating camelcase here in order to match these
                // variable names to the keys used in the report config hash.
                var mapHash = {
                    limit: { "int": CONSTANTS.LIMIT },
                    channeltype: { "string": null },
                    userid: { "int": null },
                    reporttype: { "string": null },
                    offset: { "int": CONSTANTS.OFFSET },
                    webuserid: { "int": null }
                };

                var MapConstructor =
                    function( options ) {
                        utils.copyReferences( options, mapHash );
                    };

                // Setter/getters
                MapConstructor.prototype.setLimit = function( limit ) { mapHash.limit.int = limit; };
                MapConstructor.prototype.getLimit = function() { return mapHash.limit.int; };
                MapConstructor.prototype.setChanneltype = function( channeltype ) { mapHash.channeltype.string = channeltype; };
                MapConstructor.prototype.getChanneltype = function() { return mapHash.channeltype.string; };
                MapConstructor.prototype.setUserid = function( userid ) { mapHash.userid.int = userid; };
                MapConstructor.prototype.getUserid = function() { return mapHash.userid.int; };
                MapConstructor.prototype.setReporttype = function( reporttype ) { mapHash.reporttype.string = reporttype; };
                MapConstructor.prototype.getReporttype = function() { return mapHash.reporttype.string; };
                MapConstructor.prototype.setOffset = function( offset ) { mapHash.offset.int = offset; };
                MapConstructor.prototype.getOffset = function() { return mapHash.offset.int; };
                MapConstructor.prototype.setWebuserid = function( webuserid ) { mapHash.webuserid.int = webuserid; };
                MapConstructor.prototype.getWebuserid = function() { return mapHash.webuserid.int; };

                MapConstructor.prototype.get = function() { return mapHash; };
                return MapConstructor;
            };

    var DataSourceCriteriaFactory =
        /**
         * Define the DataSourceCriteria constructor. We get access to
         * CONSTANTS and utils above so that calls to this service (constructor)
         * do not need to include them.
         */
        (function() {

            /*
                A DataSourceCriteria definition includes these major sections:

                basicSettings
                -------------



                sortInfo
                --------



                filter
                ------



                comparableDateRange
                -------------------



                map
                ---



                It also includes a number of other top-level attributes (defaults, suggested values in parens):
                    columnGroup ("DEFAULT")
                    sortPreset (-1)
                    bulkSettings (null)
                    allowNestedValues (true)
                    aggregationList ([ {} ])


             */

            var columnGroup, sortPreset, bulkSettings, allowNestedValues;

            return function( reportServiceConstants, utilitiesFactory ) {

                utils = utilitiesFactory;
                CONSTANTS = reportServiceConstants;

                columnGroup = CONSTANTS.COLUMN_GROUP;
                sortPreset = CONSTANTS.SORT_PRESET;
                bulkSettings = CONSTANTS.BULK_SETTINGS;
                allowNestedValues = CONSTANTS.ALLOW_NESTED_VALUES;
                
                var DataSourceCriteriaConstructor =
                    /**
                     * Our constructor. We can create a new instance from either a hash that
                     * contains data like id or width or we can create one from a ColumnMetadata instance.
                     * @param options This can be either an instance of ColumnMetadata or a simple hash.
                     *                  We don't have direct access to this
                     * @constructor
                     */
                    function( options ) {
                        // Look in here for the report criteria attributes we need. The user can
                        // always add ones separately.
                        if (!! options) {
                            if (typeof options.columnGroup !== "undefined") { this.columnGroup = options.columnGroup; }
                            if (typeof options.sortPreset !== "undefined") { this.sortPreset = options.sortPreset; }
                            if (typeof options.bulkSettings !== "undefined") { this.bulkSettings = options.bulkSettings; }
                            if (typeof options.allowNestedValues !== "undefined") { this.allowNestedValues = options.allowNestedValues; }

                            if (typeof options.basicSettings !== "undefined") { this.basicSettings = new DataSourceCriteriaConstructor.BasicSettings( options ); }
                            if (typeof options.filterDefinition !== "undefined") { this.filterDefinition = new DataSourceCriteriaConstructor.Filter.FilterDefinition( options ); }
                            if (typeof options.sortInfo !== "undefined") { this.sortInfo = new DataSourceCriteriaConstructor.SortInfo( options ); }
                            if (typeof options.map !== "undefined") { this.map = new DataSourceCriteriaConstructor.Map( options ); }
                        }

                        // Create defaults where appropriate
                        if (! this.basicSettings) { this.basicSettings = new DataSourceCriteriaConstructor.BasicSettings(); }
                        if (! this.filterDefinition) { this.filterDefinition = new DataSourceCriteriaConstructor.Filter.FilterDefinition(); }
                        if (! this.sortInfo) { this.sortInfo = new DataSourceCriteriaConstructor.SortInfo(); }
                        if (! this.map) { this.map = new DataSourceCriteriaConstructor.Map(); }

                    };

                DataSourceCriteriaConstructor.prototype.getColumnGroup = function() { return this.columnGroup; };
                DataSourceCriteriaConstructor.prototype.getBasicSettings = function() { return this.basicSettings; };
                DataSourceCriteriaConstructor.prototype.getFilterDefinition = function() { return this.filterDefinition; };
                DataSourceCriteriaConstructor.prototype.getSortInfo = function() { return this.sortInfo; };
                DataSourceCriteriaConstructor.prototype.getMap = function() { return this.map; };

                // Add the specialty constructors to this constructor.
                DataSourceCriteriaConstructor.BasicSettings = initializeBasicSettings();
                DataSourceCriteriaConstructor.SortInfo = initializeSortInfo();
                DataSourceCriteriaConstructor.Map = initializeMap();
                DataSourceCriteriaConstructor.Filter = initializeFilterInfo();

                DataSourceCriteriaConstructor.prototype.getConstructors =
                    function() {
                        return {
                            BasicSettings: DataSourceCriteriaConstructor.BasicSettings,
                            SortInfo: DataSourceCriteriaConstructor.SortInfo,
                            Map: DataSourceCriteriaConstructor.Map,
                            Filter: DataSourceCriteriaConstructor.Filter
                        };
                    };


                // Sort helper method.
                DataSourceCriteriaConstructor.prototype.addSortSpecification =
                    /**
                     * Helper for adding a sort definition to the sortInfo object. See SortInfo.addSort
                     * @param field
                     * @param direction
                     * @param atEnd
                     */
                        function( field, direction, atEnd ) {
                        this.sortInfo.addSort( field, direction, atEnd );
                    };

                // Filter helper methods.
                DataSourceCriteriaConstructor.prototype.addStringFilter =
                    function( attribute, comparison, value, caseInsensitive ) {
                        this.getFilterDefinition().addFilter( new DataSourceCriteriaConstructor.Filter.StringFilter( attribute, comparison, value, caseInsensitive ) );
                    };
                DataSourceCriteriaConstructor.prototype.addComparableFilter =
                    function( attribute, comparison, value ) {
                        this.getFilterDefinition().addFilter( new DataSourceCriteriaConstructor.Filter.ComparableFilter( attribute, comparison, value ) );
                    };
                DataSourceCriteriaConstructor.prototype.removeFilters =
                    /**
                     * Removes filter criteria. Typically used before the user adds a new filter criteria.
                     * @param attribute If not null then only the filter(s) for this attribute are removed.
                     */
                    function( attribute ) {
                        // todo support attribute-level removal.
                        this.filterDefinition = new DataSourceCriteriaConstructor.Filter.FilterDefinition();
                    };

                return DataSourceCriteriaConstructor;
            };
        }());

    // Add this to the grid module as a value.
    angular.module( "DataSourcesModule" )
        .factory(
            "DataSourceCriteria",
            ["DataSourcesConstants", "UtilitiesFactory", DataSourceCriteriaFactory]
        );

}());
